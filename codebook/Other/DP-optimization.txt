單調性

第二種優化的方法是使用轉移方程本身的特性，以減少需考慮的子狀態數目。在講這種優化
前我們先定義兩種 DP 的問題：
1D/1D DP[j] = min(0≤i<j) { DP[i] + w(i, j) }; DP[0] = k
2D/1D DP[i][j] = min(i<k≤j) { DP[i][k - 1] + DP[k][j] } + w(i, j); DP[i][i] = 0
定義 DP 的類型後，我們來定義單調性。

1. 凹四邊形不等式 (concave Monge condition)
若 A 要滿足凹四邊形不等式，則對任意 a < b, c < d 要有 A[a][c] + A[b][d] ≥ A[a][d] + A[b][c]
2. 凸四邊形不等式 (convex Monge condition)
若 A 要滿足凸四邊形不等式，則對任意 a < b, c < d 要有 A[a][c] + A[b][d] ≤ A[a][d] + A[b][c]
3. 凹完全單調性 (concave totally monotone)
若 A 要滿足凹完全單調性，則對任意 a < b, c < d 要有 A[a][c] ≤ A[b][c] => A[a][d] ≤ A[b][d]
4. 凸完全單調性 (convex totally monotone)
若 A 要滿足凸完全單調性，則對任意 a < b, c < d 要有 A[a][c] ≥ A[b][c] => A[a][d] ≥ A[b][d]
其中由 1 可推得 3，由 2 可推得 4。而要判斷一個函數 w(i, j)是否符合凹四邊形不等式，等價於要檢驗 w(i, j) + w(i + 1, j + 1) ≥ w(i, j + 1) + w(i + 1, j) 是否成立。同理，若我們要判斷函式 w(i, j)是否符合凸四邊形不等式，也只需檢驗 w(i, j) + (i + 1, j + 1) ≤ w(i, j + 1) + w(i + 1, j)。


凹性 1D/1D 優化

若定義 F[i][j] = DP[i] + w(i, j)，則若 w(i, j)符合凹四邊形不等式，可推知 F 必定也符合。此時 F[i][j]即具有凹完全單調性。而根據定義，DP[j]會是 min0≤i<jF[i][j]，所以我們用一資料結構來維護每條尚未計算之行的當前最小值在哪。且若 DP[j]已完成，由凹四邊形不等式，F[j + 1] ~ F[n]的當前最佳解位置必遞減。

右圖是剛得出 DP[j]而未將 DP[j]加入資料結構前的狀態，一但我們成功將第 j 列加入後，我們即可直接將第 j+1 行的當前最佳解視為 DP[j + 1]之值。(因為此時 F[0][j + 1] ~ F[j][j + 1]都被考慮到了)所以 DP 的瓶頸是在我們如何維護此結構。

一般而言對 1D/1D 凹的問題我們使用 Stack 來維護當前最佳解，Stack 中的每個元素都包含三個值(L, R, p)，代表在 L ~ R 行得當前最佳解是 p。當我們要加入新的一行 j 時，有兩種 case：

1. F[j][j + 1] ≥ F[Stack.top().p][j + 1]
這代表在第 j+1 行時最佳解的位置就已經比 j 還要小了，故此行根本無需加入。

2. F[j][j + 1] < F[Stack.top().p][j + 1]
此時代表列 j 是有必要加入的，於是我們從 Stack 的頂端開始考慮。若以(nL, nR, np)代表當前Stack 頂端元素的(nL, nR, np)則若 F[j][nR] < F[np][nR]就將 Stack 頂端的元素丟棄，如此反覆直到 Stack 已經空了或是 F[j][nR] ≥ F[np][nR]。當發生第一種狀況時直接 push 入(j + 1, n, j)即可，然而若是第二種狀況則需在(nL, nR)之間二分搜，找到第一次發生列 np 比列 j 好的地方。設此點為 m，則需將 Stack 頂端之元素修正為(m, nR, np)後再 push 入(j + 1, m - 1, j)。最後只需在取值後判斷 Stack頂端之元素是否過期(nR < j + 1)，若是即將之 pop 出便可。根據以上方法我們可得一算法在 O(nlgn)內求出 DP[n]。


凸性 1D/1D 優化
凸性的 1D/1D 優化與凹性十分相似。在凸四邊形不等式的影響下，當前最佳解的位置是呈現遞增，所以在凸性 1D/1D 問題中我們改用 Deque 來維護當前最佳位置。要插入新的一列時，我們就從右邊開始刪除元素，最後一樣二分搜出確切位置。而要取值時則是從左側取出，過期的東西也是從左側拿出。

這個作法的複雜度與凹性 1D/1D 一模一樣是 O(nlgn)。不過不管是凹性還是凸性，如果能利用 w(i, j)函數的特性而在 O(1)的時間內計算出 m 點所在，複雜度便可降至 O(n)。

對於凹性的 2D/1D 問題可考慮枚舉一維後每次視為 1D/1D 的問題。定義：
DP_i[j] = min0≤k<j{ DP_i[k] + u_i(k, j) } (1 ≤ j ≤ n - i)

u_i(k, j) = DP_(i+k+1)[j - k - 1] + w(i, i + j)

若可證明 u_i(k, j)符合凹四邊形不等式，則可以凹性 1D/1D 之法解 DP_i。總複雜度為(n^2lgn)。
不過要注意的是因為 i 值較小的 u 會用到 i 值較大的 DP，故枚舉 i 值時須從大枚舉至小。


凸性 2D/1D 優化

如果 w(i, j)符合凸單調性，且有 w(i, i + 2) ≥ max(w(i, i + 1), w(i + 1, i + 2))，則 DP[i][j]也會符合凸四邊形不等式。
相較於凹性 2D/1D，凸性 2D/1D 能作的優化更多，他有一個重要的定理：
令 K[i, j]為使 DP[i][j]達到最小值的 k 值，則有 K[i][j - 1] ≤ K[i][j] ≤ K[i + 1][j]。

因為以上定理，我們 DP 時，可以從 j - i 較小的狀態開始 DP 起。當我們在作 DP[i][j]時我們只需枚舉 K[i][j - 1] ~ K[i + 1][j]，故對於所有 j - i = c 的狀態，將他們都求出所需枚舉的狀態數只有：
K[2][1 + c] - K[1][c] + 1 + K[3][2 + c] - K[2][1 + c] + 1 + K[4][3 + c] - K[3][2 + c] + 1 ….
= K[n + 1 - c][n] - K[1][c] + n - c = O(n)。
而 j - i 總共只有 O(n)種，故求出整個 DP 表格便只需要 O(n^2)，比起直接枚舉快了一維。切記 2D/1D 的凸單調性優化算是這四種中在競賽最常見的，甚至在 TOI 模考中也出過，所以就算其他三種單調優化都不會，也得弄清楚這種。
